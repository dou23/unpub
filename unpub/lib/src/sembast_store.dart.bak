// import 'dart:convert';

// import 'package:path/path.dart' as path;
// import 'package:sembast/sembast.dart';
// import 'package:sembast/sembast_io.dart';
// import 'package:intl/intl.dart';
// import 'package:unpub/src/models.dart';
// import 'meta_store.dart';

// final packageCollection = 'packages';
// final statsCollection = 'stats';

// class SembastStore extends MetaStore {
//   late Database db;

//   SembastStore() {
//     _initDb();
//   }

//   Future<void> _initDb() async {
//     db = await databaseFactoryIo.openDatabase(
//       path.join('.dart_tool', 'sembast', 'example', 'record_demo.db'),
//     );
//   }

//   static Filter _selectByName(String? name) => Filter.equals('name', name);

//   Future<UnpubQueryResult> _queryPackagesBySelector(Filter selector) async {
//     final count = intMapStoreFactory
//         .store(packageCollection)
//         .countSync(db, filter: selector);
//     final packages = intMapStoreFactory
//         .store(packageCollection)
//         .findSync(db, finder: Finder(filter: selector))
//         .map((item) => UnpubPackage.fromJson(item.value))
//         .toList();
//     return UnpubQueryResult(count, packages);
//   }

//   @override
//   queryPackage(name) async {
//     var json = await intMapStoreFactory
//         .store(packageCollection)
//         .findFirst(db, finder: Finder(filter: _selectByName(name)));
//     if (json == null || json.value == null) return null;
//     return UnpubPackage.fromJson(json.value);
//   }

//   @override
//   addVersion(name, version) async {
//     var updateMap = new Map<String, Object?>();
//     updateMap['versions'] = version.toJson();
//     updateMap['uploaders'] = version.uploader;
//     updateMap['createdAt'] = version.createdAt;
//     updateMap['private'] = true;
//     updateMap['download'] = 0;
//     updateMap['updatedAt'] = version.createdAt;

//     // intMapStoreFactory
//     // .store(packageCollection)
//     // .update(db, updateMap, finder: Finder(filter: _selectByName(name)));
//     await _addOrUpdateProduct(intMapStoreFactory.store(packageCollection),
//         updateMap, _selectByName(name));
//   }

//   Future<void> _addOrUpdateProduct(StoreRef<int, Map<String, Object?>> store,
//       Map<String, Object?> map, Filter f) async {
//     // Check if the record exists before adding or updating it.
//     await db.transaction((txn) async {
//       // Look of existing record
//       var existing =
//           await store.query(finder: Finder(filter: f)).getSnapshot(txn);
//       if (existing == null) {
//         // code not found, add
//         await store.add(txn, map);
//       } else {
//         // Update existing
//         await existing.ref.update(txn, map);
//       }
//     });
//   }

//   @override
//   addUploader(name, email) async {
//     await db
//         .collection(packageCollection)
//         .update(_selectByName(name), modify.push('uploaders', email));
//   }

//   @override
//   removeUploader(name, email) async {
//     await db
//         .collection(packageCollection)
//         .update(_selectByName(name), modify.pull('uploaders', email));
//   }

//   @override
//   increaseDownloads(name, version) {
//     var today = DateFormat('yyyyMMdd').format(DateTime.now());
//     db
//         .collection(packageCollection)
//         .update(_selectByName(name), modify.inc('download', 1));
//     db
//         .collection(statsCollection)
//         .update(_selectByName(name), modify.inc('d$today', 1));
//   }

//   @override
//   Future<UnpubQueryResult> queryPackages({
//     required size,
//     required page,
//     required sort,
//     keyword,
//     uploader,
//     dependency,
//   }) {
//     var selector =
//         where.sortBy(sort, descending: true).limit(size).skip(page * size);

//     if (keyword != null) {
//       selector = selector.match('name', '.*$keyword.*');
//     }
//     if (uploader != null) {
//       selector = selector.eq('uploaders', uploader);
//     }
//     if (dependency != null) {
//       selector = selector.raw({
//         'versions': {
//           r'$elemMatch': {
//             'pubspec.dependencies.$dependency': {r'$exists': true}
//           }
//         }
//       });
//     }

//     return _queryPackagesBySelector(selector);
//   }
// }
